<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>單向鏈結串列 Singly linked list - Rust Algorithm Club</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learn algorithms and data structures with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Rust Algorithm Club</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">💡 基礎概念</li><li class="chapter-item expanded "><a href="../../concepts/asymptotic-notation/index.html">漸進符號 Asymptotic Notation</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">🔍 搜尋</li><li class="chapter-item expanded "><a href="../../searching/linear_search/index.html">線性搜尋 Linear search</a></li><li class="chapter-item expanded "><a href="../../searching/binary_search/index.html">二元搜尋 Binary search</a></li><li class="chapter-item expanded "><a href="../../searching/interpolation_search/index.html">內插搜尋 Interpolation search</a></li><li class="chapter-item expanded "><a href="../../searching/exponential_search/index.html">指數搜尋 Exponential search</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">📚 排序</li><li class="chapter-item expanded affix "><li class="part-title">簡單排序</li><li class="chapter-item expanded "><a href="../../sorting/insertion_sort/index.html">插入排序 Insertion sort</a></li><li class="chapter-item expanded "><a href="../../sorting/selection_sort/index.html">選擇排序 Selection sort</a></li><li class="chapter-item expanded "><a href="../../sorting/bubble_sort/index.html">氣泡排序 Bubble sort</a></li><li class="chapter-item expanded "><a href="../../sorting/shellsort/index.html">希爾排序 Shellsort</a></li><li class="chapter-item expanded affix "><li class="part-title">高效排序</li><li class="chapter-item expanded "><a href="../../sorting/heapsort/index.html">堆積排序 Heapsort</a></li><li class="chapter-item expanded "><a href="../../sorting/quicksort/index.html">快速排序 Quicksort</a></li><li class="chapter-item expanded "><a href="../../sorting/mergesort/index.html">合併排序 Mergesort</a></li><li class="chapter-item expanded affix "><li class="part-title">混合排序</li><li class="chapter-item expanded "><div>🚧 內省排序 Introsort</div></li><li class="chapter-item expanded "><div>🚧 自適應合併排序 Timsort</div></li><li class="chapter-item expanded "><div>🚧 模式消除快速排序 Pdqsort</div></li><li class="chapter-item expanded affix "><li class="part-title">特殊排序</li><li class="chapter-item expanded "><a href="../../sorting/counting_sort/index.html">計數排序 Counting sort</a></li><li class="chapter-item expanded "><a href="../../sorting/bucket_sort/index.html">桶排序 Bucket sort</a></li><li class="chapter-item expanded "><a href="../../sorting/radix_sort/index.html">基數排序 Radix sort</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">🏠 資料結構</li><li class="chapter-item expanded affix "><li class="part-title">堆疊與佇列</li><li class="chapter-item expanded "><a href="../../collections/stack/index.html">堆疊 Stack</a></li><li class="chapter-item expanded "><a href="../../collections/queue/index.html">佇列 Queue</a></li><li class="chapter-item expanded "><div>🚧 雙端佇列 Deque</div></li><li class="chapter-item expanded affix "><li class="part-title">鏈結串列</li><li class="chapter-item expanded "><a href="../../collections/linked_list/index.html">鏈結串列概述</a></li><li class="chapter-item expanded "><a href="../../collections/singly_linked_list/index.html" class="active">單向鏈結串列 Singly linked list</a></li><li class="chapter-item expanded "><div>🚧 雙向鏈結串列 Doubly linked list</div></li><li class="chapter-item expanded "><div>🚧 循環鏈結串列 Circular linked list</div></li><li class="chapter-item expanded affix "><li class="part-title">關聯容器</li><li class="chapter-item expanded "><a href="../../collections/associative-container/index.html">關聯容器概述</a></li><li class="chapter-item expanded "><a href="../../collections/hash_map/index.html">雜湊表 Hash map</a></li><li class="chapter-item expanded "><div>🚧 有序映射表 Ordered map</div></li><li class="chapter-item expanded "><div>🚧 多重映射表 Multimap</div></li><li class="chapter-item expanded "><a href="../../collections/set/index.html">集合 Set</a></li><li class="chapter-item expanded "><a href="../../collections/bloom_filter/index.html">布隆過濾器 Bloom filter</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">🧵 字串處理</li><li class="chapter-item expanded "><a href="../../hamming_distance/index.html">漢明距離 Hamming distance</a></li><li class="chapter-item expanded "><a href="../../levenshtein_distance/index.html">萊文斯坦距離 Levenshtein distance</a></li><li class="chapter-item expanded "><div>🚧 最長共同子字串 Longest common substring</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../../CONTRIBUTING.html">貢獻指南</a></li><li class="chapter-item expanded affix "><a href="../../404.html">404</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust Algorithm Club</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/weihanglo/rust-algorithm-club" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#單向鏈結串列-singly-linked-list" id="單向鏈結串列-singly-linked-list">單向鏈結串列 Singly linked list</a></h1>
<p>單向鏈結串列是鏈結串列家族中最簡單的版本，特色是每兩個節點間只有一個單向的鏈結。</p>
<pre><code>   head
    |
    v
+--------+   +--------+   +--------+
|        |   |        |   |        |
| node 0 |--&gt;| node 1 |--&gt;| node 2 |--&gt; NULL
|        |   |        |   |        |
+--------+   +--------+   +--------+
</code></pre>
<p>比起 <a href="doubly.html">雙向鏈結串列</a>，單向鏈結串列少了一個額外的指標開銷，在基本操作的花費也較低。在不需要雙向疊代情形下單向鏈結串列很適用。</p>
<p>此外，單向鏈結串列也支援 tail-sharing，也就是共享 sublist。藉由共享 sublist，單向鏈結串列很容易實作 <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>，再配合 immutable 特性，使得單向鏈結串列幾乎成為函數式程式語言最常見的集合型別之一。可以參考這篇 <a href="http://cglab.ca/%7Eabeinges/blah/too-many-lists/book/third.html">persistent immutable stack 實作</a>文章。</p>
<blockquote>
<p>本次實作的程式碼置於 <a href="/doc/rust_algorithm_club/collections/struct.SinglyLinkedList.html"><code>rust_algorithm_club::collections::SinglyLinkedList</code></a> API 文件中。</p>
</blockquote>
<h2><a class="header" href="#實作設計" id="實作設計">實作設計</a></h2>
<h3><a class="header" href="#node" id="node">Node</a></h3>
<p>先建立最基本的節點 Node。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// cannot compile
struct Node&lt;T&gt; {
    elem: T,
    next: Node&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Node.elem</code> 很直觀地儲存實際資料。而 <code>Node.next</code> 則是指向下個 Node。但這樣編譯不會成功，Rust 編譯時需要決定每個型別該配置多少記憶體空間，這種遞迴型別使得編譯器無限循環，無法決定配置大小。</p>
<p><img src="node-recursive.svg" alt="node-recursive" /></p>
<p>很簡單，我們使用 <a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code></a> 這個<a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">智慧指標</a>，直接將 Node 配置在記憶體 heap 上。如此以來，編譯器就會知道 <code>next</code> 只佔了一個指標的空間。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node&lt;T&gt; {
    elem: T,
    next: Box&lt;Node&lt;T&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="node-box.svg" alt="node-box" /></p>
<p>由於 Rust 沒有 null pointer，但照鏈結串列的定義，<code>Node.next</code> 可以是 NULL，因此我們使用 <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option&lt;T&gt;</code></a> 模擬 null pointer 的行為。最後，Node 的定義如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node&lt;T&gt; {
    elem: T,
    next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#singlylinkedlist" id="singlylinkedlist">SinglyLinkedList</a></h3>
<p>在開始實作各種增刪節點的操作之前，我們需要建立一個 struct 存放指向鏈結串列 head 的指標，同時，各種操作也會實作在這個 struct 上。事實上，這個 struct 就是對外公開的資料結構。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SinglyLinkedList&lt;T&gt; {
    head: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>選擇把操作串列的函式寫在另一個 struct 而非 Node 上有幾個原因，1）外部並不需知道串列內部如何實作，公開 Node 會暴露實作。2）每個 Node 都帶有成員函式的話，函式指標會佔用太多額外資源。</p>
<h2><a class="header" href="#基本操作" id="基本操作">基本操作</a></h2>
<p>串列的基本操作如下：</p>
<ul>
<li><code>new</code>：初始化一個空串列。</li>
<li><code>push_front</code>：新增節點到開頭的位置。</li>
<li><code>pop_front</code>：將開頭第一個節點移除。</li>
<li><code>insert_after</code>：在指定索引位置後插入一個新節點。</li>
<li><code>remove</code>：移除任意索引下的節點。</li>
<li><code>clear</code>：清除所有節點。</li>
<li><code>is_empty</code>：檢查串列是否沒有任何節點。</li>
<li><code>reverse</code>：反轉整個串列（head 變成 tail）。</li>
</ul>
<h3><a class="header" href="#初始化與清除資料" id="初始化與清除資料">初始化與清除資料</a></h3>
<p>實做初始化與清除資料非常直觀。其中清除其實就只是將 <code>self</code> 指向新的串列實例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; SinglyLinkedList&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self { head: None }
    }

    pub fn clear(&amp;mut self) {
        *self = Self::new();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>你可能會想，在清除所有資料時，資源需不需要手動釋放？</p>
<p>和 C++ 的 RAII 一樣，Rust 有一個名叫 <code>drop</code> 的解構式，只要程式執行離開了資源擁有者的可視範圍（out of scope），就會自動呼叫 <code>drop</code>。我們在 <a href="#drop-trait">Drop trait</a> 一節會再深入探討。</p>
<h3><a class="header" href="#增刪首個節點" id="增刪首個節點">增刪首個節點</a></h3>
<p>單向鏈結串列在第一個節點前增加新節點，或是刪除第一個節點，都可以在常數時間完成。新增節點 <code>push_front</code> 的概念很簡單，1）建立新的節點，並把新節點 <code>next</code> 指標指向串列第一個節點。2）把串列的 head 指向新建立的節點。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn push_front(&amp;mut self, elem: T) {
    let next = self.head.take(); // 1
    self.head = Some(Box::new(Node { elem, next })); // 2
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>釋放 SinglyLinkedList 對第一個節點的所有權</li>
<li>建立一新節點，並將原本第一個節點所有權轉移給新節點。再將新節點所有權轉移到串列本身。</li>
</ol>
<p>刪除第一個節點 <code>pop_front</code> 的實作步驟如下：首先取得第一個節點的所有權，再將 head 指向第一個節點 <code>Node.next</code> 下一個節點，再返回第一個節點的資料給呼叫端。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    let head = self.head.take(); // 1
    match head {
        Some(node) =&gt; {
            self.head = node.next;  // 2
            Some(node.elem)         // 3
        }
        None =&gt; None,
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>取得第一個元素的所有權。</li>
<li>將 head 指向下一個節點。</li>
<li>返回即將刪除節點的資料。</li>
</ol>
<h3><a class="header" href="#插入刪除任意節點" id="插入刪除任意節點">插入刪除任意節點</a></h3>
<p>鏈結串列新增和刪除第一個節點都可以在 $O(1)$ 時間內做完，那為什麼插入刪除任意節點沒有辦法呢？原因是鏈結串列不支援隨機存取（random access），就是無法透過索引在常數時間內取得資料，每次的搜尋都只能從 head 開始。因此，當我們需要在某個索引的節點後新增一筆資料，我們會需要最差 $O(n)$ 的複雜度。</p>
<p>實作插入 <code>insert_after</code> 分為幾個步驟：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn insert_after(&amp;mut self, pos: usize, elem: T) -&gt; Result&lt;(), usize&gt; {
    let mut curr = &amp;mut self.head;
    let mut pos_ = pos;

    while pos_ &gt; 0 {                        // 1
        curr = match curr.as_mut() {
            Some(node) =&gt; &amp;mut node.next,
            None =&gt; return Err(pos - pos_),
        };
        pos_ -= 1;
    }

    match curr.take() {                     // 2
        Some(mut node) =&gt; {   // Node A
            let new_node = Box::new(Node {  // 3: Node B
                elem,
                next: node.next,
            });
            node.next = Some(new_node);     // 4
            *curr = Some(node);             // 5
        }
        None =&gt; return Err(pos - pos_)
    }
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>找到對應索引值的節點 A，若找不到則回傳這個串列的資料長度。</li>
<li>先取得節點 A 的所有權，才能修改它的值。</li>
<li>建立新節點 B，同時將節點 B 的 <code>next</code> 指向 A 的後一個節點。</li>
<li>將新節點 B 做為節點 A 後一個節點 <code>next</code>。</li>
<li>把修改過的節點 A，重新賦值給指向節點 A 的指標 <code>curr</code>（可視為歸還所有權）。</li>
</ol>
<p>而實作刪除任意索引下的節點 <code>remove</code> 和插入非常相似。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn remove(&amp;mut self, pos: usize) -&gt; Option&lt;T&gt; {
    let mut curr = &amp;mut self.head;
    let mut pos = pos;

    while pos &gt; 0 {                // 1
        curr = match curr.as_mut() {
            Some(node) =&gt; &amp;mut node.next,
            None =&gt; return None,
        };
        pos -= 1;
    }

    match curr.take() {            // 2
        Some(node) =&gt; { // Node A
            *curr = node.next;     // 3: node.next is Node B
            Some(node.elem)        // 4
        }
        None =&gt; None
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>找到對應索引值的節點 A，若找不到則回傳 <code>None</code>。</li>
<li>先取得節點 A 的所有權，才能修改它的值。</li>
<li>把節點 A 的後一個節點 B 賦值給原本指向節點 A 的指標 <code>curr</code>。</li>
<li>回傳節點 A 的值。</li>
</ol>
<h3><a class="header" href="#反轉" id="反轉">反轉</a></h3>
<p>反轉鏈結串列是工作面試時很常見的考題，這裡來實作看看。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn reverse(&amp;mut self) {
    let mut prev = None;              // 1: prev -&gt; Node P
    let mut curr = self.head.take();  // 2
    while let Some(mut node) = curr { // 3: node -&gt; Node A
        let next = node.next;         // 3-1: next -&gt; Node B
        node.next = prev.take();      // 3-2
        prev = Some(node);            // 3-3
        curr = next;                  // 3-4
    }
    self.head = prev.take(); // 4
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>先建立一個暫時變數 <code>prev</code>，儲存疊代時的前一個節點。</li>
<li>從串列 head 取得第一個節點的所有權。</li>
<li>依序疊代整個串列
<ol>
<li>將節點 A 的後一個節點 B 暫存起來。</li>
<li>節點 A 的 <code>next</code> 指向暫存在變數 <code>prev</code> 的節點 P。</li>
<li>節點 A 暫存在變數 <code>prev</code> 內，保留到下一個疊代使用。</li>
<li>將節點 B 儲存在變數 <code>curr</code> 內。此時<br />
<code>prev</code>：節點 A，A 的 <code>next</code> 指向 P，<br />
<code>curr</code>：節點 B，B 的 <code>next</code> 指向 A。</li>
</ol>
</li>
<li>最後一次疊代時，變數 <code>prev</code> 會儲存原始串列末端節點，這時轉移所有權到 head，完成反轉。</li>
</ol>
<h2><a class="header" href="#traits" id="traits">Traits</a></h2>
<p>除了基本操作，<code>SinglyLinkedList</code> 實作了許多 trait，使用上更方便更符合 Rust 的慣例。</p>
<h3><a class="header" href="#drop-trait" id="drop-trait">Drop trait</a></h3>
<p>如果一個 struct 有許多成員，則會遞迴呼叫 struct 的 <code>drop</code> 成員函式。因此，一個串列的解構式很可能發生深層的巢狀遞迴：</p>
<pre><code># a linked list
a -&gt; b -&gt; c -&gt; x -&gt; y -&gt; z

# call stack when `drop` being called

(a.drop
  (b.drop
    (c.drop
      (x.drop
        (y.drop
          (z.drop
          (z.dropped
        (y.dropped
      (x.dropped
    (c.dropped
  (b.dropped
(a.dropped
</code></pre>
<p>如果節點一多，肯定會 stack overflow，太可怕了！</p>
<p>既然如此，那麼就透過 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait</a>，實作一個疊代版本的解構式，消弭可怕的 call stack 吧。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for SinglyLinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut link = self.head.take();  // 1
        while let Some(mut node) = link { // 2
            link = node.next.take();      // 3
        }                                 // 4
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>取得 head 的所有權。</li>
<li>透過 pattern matching 取得 Node 裡面 Box 的所有權。</li>
<li>取得下一個 Node 的所有權，並將它指向共用的變數 <code>link</code>。</li>
<li>離開了 <code>node</code> 的 scope，<code>node</code> 呼叫 <code>drop</code> 釋放自身資源。 </li>
</ol>
<blockquote>
<p>詳細思路過程可查看 Learning Rust With Entirely Too Many Linked Lists 的 <a href="http://cglab.ca/%7Eabeinges/blah/too-many-lists/book/first-drop.html">Drop</a> 章節，該章完整闡述為什麼不能用 tail recursive 來實作，但最大的原因是 Rust core team 暫時延緩實踐 <a href="https://github.com/rust-lang/rfcs/pull/1888">tail call optimization</a>。</p>
</blockquote>
<p>實際上，透過呼叫 <code>pop_front()</code>，不斷移除第一個節點，並使用 <code>is_some()</code> 檢查是否仍有節點，幾乎可以達到同樣的 drop 效果，而且更簡潔易懂。差別僅在於，相較於前個實作自己處理 call stack，這個實作每次移除元素都需要 <code>pop_front()</code> 與 <code>is_some()</code> 的 stack，多了些微小的開銷。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for SinglyLinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#iterator-and-intoiterator-traits" id="iterator-and-intoiterator-traits">Iterator and IntoIterator traits</a></h3>
<p>既然鏈結串列是一種序列（sequence，有序的資料結構），少不了實作 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a>、<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">IntoIterator</a> 等 trait，使串列可以輕鬆使用 for-in loop 遍歷（traverse）。</p>
<p>首先，先定義幾個疊代器的 struct。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T&gt;(SinglyLinkedList&lt;T&gt;);

pub struct Iter&lt;'a, T: 'a&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T: 'a&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>建立這三個 iterator struct 是常見的 Rust 設計模式。</p>
<ul>
<li><code>IntoIter</code>：產生 <code>T</code>，實作會吃掉元素所有權的 <code>IntoIterator</code> trait</li>
<li><code>Iter</code>：產生 <code>&amp;T</code>，實作提供 immutable borrow 的 <code>Iterator</code> trait。</li>
<li><code>IterMut</code>：產生 <code>&amp;mut T</code>，實作提供 mutable borrow 的 <code>Iterator</code> trait。</li>
</ul>
<p>相對應的，<code>SinglyLinkedList</code> 則新增三個成員函式：</p>
<ul>
<li><code>fn into_iter(self) -&gt; IntoIter&lt;T&gt;</code>：轉移所有權的疊代器。<em>Into</em> 一詞慣例上指涉所有權移轉。</li>
<li><code>fn iter(&amp;self) -&gt; Iter&lt;T&gt;</code>：以 immutable reference 疊代串列。</li>
<li><code>fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt;</code>：以 mutable reference 疊代串列。</li>
</ul>
<p>先來看 <code>IntoIter</code> 實作。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T&gt;(SinglyLinkedList&lt;T&gt;);      // 1

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {                // 2
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop_front()
    }
}

impl&lt;T&gt; IntoIterator for SinglyLinkedList&lt;T&gt; {    // 3
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>宣告一個 tuple struct，唯一的成員是 <code>SinglyLinkedList</code>。</li>
<li>實作 <code>Iterator</code> trait 的 required method <code>next</code>，為了達成 <em>Into</em> 會消耗原始資料，轉換所有權的特性，我們利用 <code>pop_front()</code> 將節點的資料依序刪除（pop）。</li>
<li><code>IntoInterator</code> 的 required method 傳遞 <code>self</code> 進來，所以無論怎麼實作 <code>IntoIter</code> struct，呼叫 <code>into_iter()</code> 後，外部就無法再次存取此 <code>SinglyLinkedList</code> 實例，達到所有權轉移的目標。</li>
</ol>
<blockquote>
<p>可能有人會疑惑，<code>IntoIter</code> 並沒有內部狀態記錄欄位，疊代器如何依據狀態產生下一筆資料？受惠於 <code>IntoIterator</code> 傳遞所有權的特性，<code>IntoIter</code> 可直接改變原始串列的內部狀態，例如 <code>pop_front</code> 會移除原始串列的節點。因此，相較於 <code>Iter</code>、<code>IterMut</code> 額外記錄狀態，<code>IntoIter</code> 不需自行記錄疊代器的疊代狀態。</p>
</blockquote>
<p>再來看看 <code>Iter</code> 怎麼實踐。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T: 'a&gt; {                    // 1
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;                          // 2
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.next {
            Some(node) =&gt; {
                self.next = node.next.as_ref().map(|node| &amp;**node); // 3, 4
                Some(&amp;node.elem)
            }
            None =&gt; None,
        }
    }
}

impl&lt;T&gt; SinglyLinkedList&lt;T&gt; {
    // ...

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {             // 5
        Iter { next: self.head.as_ref().map(|node| &amp;**node) } // 6
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>這個 struct 的 <code>next</code> 是為了儲存 <code>Node</code> 資訊，方便記錄疊代器當前的狀態。加上生命週期 <code>'a</code> 是因編譯器無法推敲 <code>Option&lt;&amp;Node&lt;T&gt;&gt;</code> 會活多久，需要顯著標明 <code>&amp;Node</code> 至少與該疊代器同生共死。</li>
<li>由於 <code>Iter</code> 是為了實作產生 <code>&amp;T</code> 的疊代器，associated type 設為  <code>&amp;'a T</code>。</li>
<li>將當前節點的後一個節點設為 <code>Iter</code> 疊代器的狀態。並回傳當前節點的資料。<br />
這邊用了 <code>as_ref()</code> 肇因於 <code>Option.map</code> 的泛型型別與 <code>Option&lt;T&gt;</code> 一樣，所以會產生所有權轉移至 <code>map</code> 的 <code>FnOnce</code> 內部。<code>as_ref()</code> 將 <code>Option&lt;T&gt;</code> 轉換成 <code>Option&lt;&amp;T&gt;</code>，<code>map</code> 就不會發生所有權的問題。</li>
<li>此外，<code>map</code> 連續使用兩個 deref 與一個轉為 reference 的操作，是將型別以下列順序轉換。
<ul>
<li><code>Option&lt;&amp;Box&lt;Node&lt;T&gt;&gt;&gt;</code> → <code>map</code></li>
<li>→ <code>&amp;Box&lt;Node&lt;T&gt;&gt;</code> → <code>*node</code></li>
<li>→ <code>Box&lt;Node&lt;T&gt;&gt;</code> → <code>**node</code></li>
<li>→ <code>Node&lt;T&gt;</code> → <code>&amp;**node</code></li>
<li>→ <code>&amp;Node&lt;T&gt;</code>（至此型別才符合回傳值）</li>
</ul>
</li>
<li>在 <code>SinglyLinkedList</code> 上加 <code>iter()</code> 成員函式回傳 <code>Iter</code> 疊代器。</li>
<li>產生疊代器初始化狀態，和第三步一模一樣。</li>
</ol>
<p>最後，<code>IterMut</code> 與 <code>Iter</code> 疊代器實作上大同小異。把 <code>Iter</code> 用到 <code>Option.as_ref()</code> 改為 <code>Option.as_mut()</code>，其他 <code>&amp;</code> 改成 <code>&amp;mut</code> 即可。</p>
<blockquote>
<p>Rust 1.14.0为Option新增了<code>as_deref()</code>和<code>as_deref_mut()</code>两种新的方法。可以直接将<code>Option&lt;T&gt;</code>或<code>&amp;Option&lt;T&gt;</code>转换为<code>Option&lt;&amp;T&gt;</code>类型，可以不再用3、4两条的方法了。因此，新的实现如下</p>
<pre><code class="language-Rust">impl&lt;T&gt; Iterator for Iter&lt;'a, T&gt; {
   type Item = &amp;'a T;                          // 2
   fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
       match self.next {
           Some(node) =&gt; {
               // self.next = node.next.as_ref().map(|node| &amp;**node); // old
               self.next = node.next.as_deref();  //new
               Some(&amp;node.elem)
           }
           None =&gt; None,
       }
    }
}
// ....
      pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
//        Iter { next: self.head.as_ref().map(|node| &amp;**node) } // old
          Iter { next: self.head.as_deref() } //new
      }
</code></pre>
<p>参考: <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref">Rust文档</a></p>
</blockquote>
<h3><a class="header" href="#partialeq-trait" id="partialeq-trait">PartialEq trait</a></h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq trait</a> 是用來實現兩個串列是否能夠比較，而我們在此定義如下：</p>
<p>有兩個 <code>SinglyLinkedList</code> Sa、Sb，Sa、Sb 的元素皆符合 <code>PartialEq</code> trait。當</p>
<ul>
<li>Sa 的總節點數 等於 Sb 的總節點數，</li>
<li>Sa 所有元素依序等於 Sb 所有元素，</li>
</ul>
<p>則稱 Sa 與 Sb 有 partial equiavalence（<code>Sa == Sb</code>）。</p>
<p>實作上我們用了 <code>iter</code> 成員函式把兩個串列 <code>zip</code> 在一起，在用 <code>all</code> 確認元素兩兩相等，十分 Rust 風格的作法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: PartialEq&gt; PartialEq for SinglyLinkedList&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        if self.len() != other.len() {
            return false;
        }
        self.iter()
            .zip(other.iter())
            .all(|pair| pair.0 == pair.1)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#debug-trait" id="debug-trait">Debug trait</a></h3>
<p>為了方便修復臭蟲，通常會實作 <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug trait</a> 印出有助於解決問題的資料。歸功於 <code>Iterator</code> 的實踐，我們可以快速用 <code>self.iter()</code> 印出所有節點內的元素，客製化 <code>Debug</code> 的顯示方式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: std::fmt::Debug&gt; std::fmt::Debug for SinglyLinkedList&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        for elem in self.iter() {
            write!(f, &quot;{:?} -&gt; &quot;, elem)?
        }
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#效能" id="效能">效能</a></h2>
<table><thead><tr><th>Operation</th><th>Complexity</th></tr></thead><tbody>
<tr><td>get</td><td>$O(n)$</td></tr>
<tr><td>insert</td><td>節點已知：$O(1)$ ；節點未知：$O(n - i)$</td></tr>
<tr><td>remove</td><td>節點已知：$O(1)$ ；節點未知：$O(n - i)$</td></tr>
<tr><td>append</td><td>$O(n)$</td></tr>
<tr><td>prepend</td><td>$O(1)$</td></tr>
<tr><td>pop first</td><td>$O(1)$</td></tr>
<tr><td>pop last</td><td>$O(n)$</td></tr>
<tr><td>space</td><td>$O(n)$ + 各節點額外一個指標 $n$ 個</td></tr>
</tbody></table>
<blockquote>
<p>$n$：資料筆數。<br />
$i$：相對於整個容器的索引位置。</p>
</blockquote>
<p>值得觀察的是，許多操作因為單向鏈結串列只能從 head 開始搜索的緣故，執行時間都呈線性，使用上要特別注意。</p>
<h2><a class="header" href="#參考資料" id="參考資料">參考資料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/src/alloc/linked_list.rs.html">Rust Documentation: LinkedList</a></li>
<li><a href="http://cglab.ca/%7Eabeinges/blah/too-many-lists/book/README.html">Learning Rust With Entirely Too Many Linked Lists</a></li>
<li><a href="https://stackoverflow.com/questions/51134192/">Duscussions at Stackoverflow</a></li>
<li><a href="https://codereview.stackexchange.com/questions/150906">StackExchange: Reversal of a singly-linked list in Rust</a></li>
<li>SVG of node memory representation modified from <a href="https://doc.rust-lang.org/book">The Rust Programming Language</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../collections/linked_list/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../collections/associative-container/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../collections/linked_list/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../collections/associative-container/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../theme/custom.js"></script>
        

        

    </body>
</html>
